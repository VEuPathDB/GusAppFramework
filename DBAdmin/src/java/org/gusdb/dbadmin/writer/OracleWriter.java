/*
 * Created on Oct 28, 2004
 */
package org.gusdb.dbadmin.writer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.gusdb.dbadmin.model.Column;
import org.gusdb.dbadmin.model.Constraint;
import org.gusdb.dbadmin.model.Database;
import org.gusdb.dbadmin.model.DatabaseObject;
import org.gusdb.dbadmin.model.GusSchema;
import org.gusdb.dbadmin.model.GusTable;
import org.gusdb.dbadmin.model.GusView;
import org.gusdb.dbadmin.model.Index;
import org.gusdb.dbadmin.model.Schema;
import org.gusdb.dbadmin.model.Sequence;
import org.gusdb.dbadmin.model.Table;
import org.gusdb.dbadmin.model.View;

/**
 * @author msaffitz
 * @created May 2, 2005
 * @version $Revision$ $Date: 2005-10-28 09:42:07 -0400 (Fri, 28 Oct
 *          2005) $
 */
public class OracleWriter extends RelationalDatabaseWriter {

    private HashMap tablespacePermissions = new HashMap( );
    private HashMap tablePermissions      = new HashMap( );
    private boolean skipRoles = false;

    /**
     * @param db Description of the Parameter
     * @exception IOException Description of the Exception
     * @see org.gusdb.dbadmin.writer.SchemaWriter#writeDatabase(java.io.OutputStreamWriter,
     *      org.gusdb.dbadmin.model.Database)
     */

    protected void writeDatabase( Database db ) throws IOException {
        log.debug( "Writing database" );
        oStream.write( "-- Automatically generated by GusDBA.\n" );
        oStream.write( "-- GUS DDL for Oracle\n" );
        if ( db.getName( ) != null ) {
            oStream.write( "-- Generated for " + db.getName( ) + "\n" );
        }
        oStream.write( "\n\n" );
        if (!skipRoles) createRoles( );
        oStream.write( "\n-- Schemata\n\n" );
        for ( Schema schema : db.getAllSchemas( ) ) {
            oStream.write( "CREATE USER " + schema.getName( ) + " IDENTIFIED BY temppass PASSWORD EXPIRE ACCOUNT LOCK "
                    + " QUOTA UNLIMITED ON USERS DEFAULT TABLESPACE USERS;\n" );
        }
        oStream.flush( );
        oStream.write( "\n-- Tables, Views, Indexes, and Primary Key Constraints\n\n" );
        for ( Schema schema : db.getAllSchemas( ) ) {
            writeTables( schema );
            writeViews( schema );
        }
        oStream.flush( );
        oStream.write( "\n-- Foreign Key Constraints\n\n" );
        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( GusTable table : schema.getTables( ) ) {
                if ( schema.getClass( ) == GusSchema.class ) {
                    writeFKConstraints( table );
                    writeUQConstraints( table );
                    oStream.write( "\n" );
                }
            }
        }
        oStream.flush( );
        oStream.write( "\n-- Sequences\n\n" );
        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( Iterator j = schema.getTables( ).iterator( ); j.hasNext( ); ) {
                GusTable table = (GusTable) j.next( );

                writeSequence( table.getSequence( ) );
                oStream.write( "\n" );
            }
        }
        oStream.write( "\n\n--EOF\n" );
        written = new ArrayList<DatabaseObject>( );
    }

    public void setSkipRoles (boolean skipRoles) {
	this.skipRoles = skipRoles;
    }

    private void createRoles( ) throws IOException {
        log.debug( "Creating Roles" );
        oStream.write( "CREATE ROLE GUS_W;\n" );
        oStream.write( "CREATE ROLE GUS_R;\n" );
        oStream.write( "\n" );
    }

    protected void writeTable( Table table ) throws IOException {
        if ( written.contains( table ) ) {
            return;
        }
        log.debug( "Writing Table: " + table.getName( ) );
        if ( table.getTablespace( ) != null
                && !tablespacePermissions.containsKey( table.getSchema( ).getName( ) + table.getTablespace( ) ) ) {
            grantTablespace( table.getSchema( ).getName( ), table.getTablespace( ) );
        }
        if ( table.getSuperclass( ) != null && !written.contains( table.getSuperclass( ) ) ) {
            writeTable( table.getSuperclass( ) );
        }
        oStream.write( "CREATE TABLE " + table.getSchema( ).getName( ) + "." + table.getName( ) + " (\n" );
        writeColumns( table );
        oStream.write( ") " );
        if ( table.getTablespace( ) != null ) {
            oStream.write( "TABLESPACE " + table.getTablespace( ) + " " );
        }
        oStream.write( ";\n\n" );

        oStream.write( "GRANT SELECT ON " + table.getSchema( ).getName( ) + "." + table.getName( ) + " TO GUS_R;\n" );
        oStream.write( "GRANT UPDATE,INSERT,DELETE ON " + table.getSchema( ).getName( ) + "." + table.getName( )
                + " TO GUS_W;\n" );

        oStream.write( "\n\n" );
        oStream.flush( );
        written.add( table );
        if ( table.getClass( ) == GusTable.class ) {
            writeIndexes( (GusTable) table );
            oStream.write( "\n" );
            writePKConstraint( (GusTable) table );
        }
        oStream.write( "\n" );
    }
    
    protected void writeView( View view ) throws IOException {
        if ( written.contains( view ) ) {
            return;
        }
        super.writeView(view);
        
        oStream.write( "GRANT SELECT ON " + view.getSchema( ).getName( ) + "." + view.getName( ) + " TO GUS_R;\n" );
        oStream.write( "GRANT UPDATE,INSERT,DELETE ON " + view.getSchema( ).getName( ) + "." + view.getName( )
                + " TO GUS_W;\n" );

        oStream.write( "\n\n" );
        oStream.flush( );
    }

    protected void writeFKConstraints( GusTable table ) throws IOException {
        for ( Constraint constraint : table.getConstraints( ) ) {
            if ( constraint.getType( ) == Constraint.ConstraintType.FOREIGN_KEY ) {
                if ( !tablePermissions.containsKey( table.getSchema( ).getName( )
                        + constraint.getReferencedTable( ).getSchema( ).getName( )
                        + constraint.getReferencedTable( ).getName( ) ) ) {
                    grantReferences( table.getSchema( ).getName( ), constraint.getReferencedTable( ) );
                }
                writeFKConstraint( constraint );
            }
        }
    }

    protected void writeIndex( Index index ) throws IOException {
        Table table = index.getTable( );

        if ( index.getTablespace( ) != null
                && !tablespacePermissions.containsKey( table.getSchema( ).getName( ) + index.getTablespace( ) ) ) {
            grantTablespace( table.getSchema( ).getName( ), index.getTablespace( ) );
        }
        oStream.write( "CREATE INDEX " );
        if ( index.getName( ) == null ) {
            index.setName( "IND_" + random.nextInt( 100000 ) );
        }
        oStream.write( table.getSchema( ).getName( ) + "." + index.getName( ) + " ON " + table.getSchema( ).getName( )
                + "." + table.getName( ) + " (" );
        writeColumnList( index.getColumns( ) );
        oStream.write( ") " );
        if ( index.getTablespace( ) != null ) {
            oStream.write( "TABLESPACE " + index.getTablespace( ) );
        }
        oStream.write( ";\n" );
        oStream.flush( );
    }

    private void grantTablespace( String schema, String tablespace ) throws IOException {
        oStream.write( "ALTER USER " + schema + " QUOTA UNLIMITED ON " + tablespace + ";\n\n" );
        oStream.flush( );
    }

    private void grantReferences( String schema, Table table ) throws IOException {
        oStream.write( "GRANT REFERENCES ON " + table.getSchema( ).getName( ) + "." + table.getName( ) + " TO "
                + schema + ";\n\n" );
        oStream.flush( );
    }

    protected void writeSequence( Sequence sequence ) throws IOException {
        super.writeSequence( sequence );
        oStream.write( "\nGRANT SELECT ON " + sequence.getTable( ).getSchema( ).getName( ) + "." + sequence.getName( )
                + " TO GUS_W;\n" );
        oStream.flush( );
    }

    protected String getType( Column.ColumnType type ) {
        if ( type == Column.ColumnType.DATE ) {
            return "DATE";
        }
        else if ( type == Column.ColumnType.STRING ) {
            return "VARCHAR2";
        }
        else if ( type == Column.ColumnType.CLOB ) {
            return "CLOB";
        }
        else if ( type == Column.ColumnType.BLOB ) {
            return "BLOB";
        }
        else if ( type == Column.ColumnType.CHARACTER ) {
            return "CHAR";
        }
        else if ( type == Column.ColumnType.FLOAT ) {
            return "FLOAT";
        }
        else if ( type == Column.ColumnType.NUMBER ) {
            return "NUMBER";
        }
        log.error( "Unable to get Oracle type: " + type.toString( ) );
        throw new RuntimeException( "Unable to get Oracle type: " + type.toString( ) );
    }

}
