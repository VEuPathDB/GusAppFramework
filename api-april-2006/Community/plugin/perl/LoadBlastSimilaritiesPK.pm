package GUS::Community::Plugin::LoadBlastSimilaritiesPK;

@ISA = qw(GUS::PluginMgr::Plugin); 
use strict;

use GUS::Community::BulkSimilarity;

sub new {
  my ($class) = @_;
  my $self = {};
  bless($self,$class);

  my $usage = 'Load in blast similarities generated by generateBlastSimilarity.pl  NOTE: Both query and subject must use primary key as identifier';

  my $easycsp =
    [{o => 'subject_table',
      t => 'string',
      h => 'subjects are taken from this table (schema::table format).',
     },
     {o => 'log_frequency',
      t => 'int',
      h => 'Write line to log file once every this many entries',
      d => 10,
     },
     {o => 'query_table',
      t => 'string',
      h => 'queries are taken from this table (schema::table format). ',
     },
     {o => 'files',
      t => 'string',
      h => 'read condensed results from this file',
      l => 1,
     },
     {o => 'nqueries',
      t => 'int',
      h => 'process this many queries',
      d => 1e6,
     },
     {o => 'output',
      t => 'string',
      h => 'what type of similarity children to put in db',
      d => 'both',
      e => [ qw ( both summaries spans ) ],
     },
     {o => 'restart',
      t => 'string',
      h => 'restarts from last entry in Similarity.... takes list of row_alg_invocation_ids "234, 235"!',
     },
     {o => 'update',
      t => 'boolean',
      h => 'if true then updates existing Similarities rather than making new',
     },
     {o => 'limit_sub',
      t => 'int',
      h => 'maximum number of subjects to enter / query'
     },
     {o => 'limit_hsp',
      t => 'int',
      h => 'maximum number of hsps to enter / subject'
     },
     {o => 'ns_mi',
      t => 'int',
      h => 'minimum number of subject filter'
     },
     {o => 'ns_ma',
      t => 'int',
      h => 'maximum number of subject filter'
     },
     {o => 'su_pv',
      t => 'float',
      h => 'summary pvalue cutoff'
     },
     {o => 'su_pi',
      t => 'float',
      h => 'summary percent identity cutoff'
     },
     {o => 'su_ln',
      t => 'int',
      h => 'summary match length cutoff'
     },
     {o => 'sp_pv',
      t => 'float',
      h => 'span pvalue cutoff'
     },
     {o => 'sp_pi',
      t => 'float',
      h => 'span percent identity cutoff'
     },
     {o => 'sp_ln',
      t => 'int',
      h => 'span match length cutoff'
     },
    ];

  $self->initialize({requiredDbVersion => {},
		     cvsRevision => '$Revision$', # cvs fills this in!
		     cvsTag => '$Name$', # cvs fills this in!
		     name => ref($self),
		     revisionNotes => 'make consistent with GUS 3.0',
		     easyCspOptions => $easycsp,
		     usage => $usage
		    });
  return $self;
}


my $ctx;
my %ignore;
my %update;			##queries with existing similarities to be updated...
my $countIgnored = 0;
my $subject_table_pk;
my $query_table_pk;
my $subject_table_id;
my $query_table_id;
my $queriesProcessed = 0;

$| = 1;

sub run {
  my $M   = shift;
  $ctx = shift;

  die "LoadBlastSimilarities: you must provide a --subject_table and --query_table\n" unless ($ctx->{cla}->{subject_table} && $ctx->{cla}->{query_table});


		
  $ctx->{'self_inv'}->setMaximumNumberOfObjects(400000);

  ##get the subject table_id
  $subject_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{cla}->{ subject_table } );
  ##and the query_table_id
  $query_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{cla}->{query_table} );
  ##get the subject_table_pk
  $subject_table_pk = $ctx->{self_inv}->getTablePKFromTableId($subject_table_id);
  ##now the query table pk..
  $query_table_pk = $ctx->{self_inv}->getTablePKFromTableId($ctx->{self_inv}->getTableIdFromTableName( $ctx->{cla}->{query_table} ));

  my $queryClassName = "GUS::Model::$ctx->{cla}->{'query_table'}";
  eval("require $queryClassName");

  my $n_queries = 0;
  my $n_files   = 0;

  print $ctx->{cla}->{'commit'} ? "*** COMMIT ON ***\n" : "*** COMMIT TURNED OFF ***\n";
  print "Testing on $ctx->{cla}->{'testnumber'}\n" if $ctx->{cla}->{'testnumber'};

  # open dbi database connection
  ##note that the login and password are coming from the gus_cfg file..
  my $dbh = $ctx->{'self_inv'}->getDbHandle();

  ## want to be able to ignore entries already done!!
  if ($ctx->{cla}->{'restart'}) {
    my $query = "select distinct query_id from dots.Similarity where row_alg_invocation_id in ($ctx->{cla}->{'restart'})";
    print "Restarting: Querying for the ids to ignore\n$query\n";
    my $stmt = $dbh->prepare($query);
    $stmt->execute();
    while ( my($id) = $stmt->fetchrow_array()) {
      $ignore{$id} = 1;
    }
    print "Ignoring ".scalar(keys%ignore)." entries\n";
  }

  ##filters to pass into the Bulkloader module...
  my $filter_ns;
  $filter_ns->{ min }             = $ctx->{cla}->{ ns_mi } if defined $ctx->{cla}->{ ns_mi };
  $filter_ns->{ max }             = $ctx->{cla}->{ ns_ma } if defined $ctx->{cla}->{ ns_ma };

  my $filter_su;
  $filter_su->{ length          } = $ctx->{cla}->{ su_ml } if defined $ctx->{cla}->{ su_ml };
  $filter_su->{ pValue          } = $ctx->{cla}->{ su_pv } if defined $ctx->{cla}->{ su_pv };
  $filter_su->{ percentIdentity } = $ctx->{cla}->{ su_pi } if defined $ctx->{cla}->{ su_pi };

  my $filter_sp;
  $filter_sp->{ length          } = $ctx->{cla}->{ sp_ml } if defined $ctx->{cla}->{ sp_ml };
  $filter_sp->{ pValue          } = $ctx->{cla}->{ sp_pv } if defined $ctx->{cla}->{ sp_pv };
  $filter_sp->{ percentIdentity } = $ctx->{cla}->{ sp_pi } if defined $ctx->{cla}->{ sp_pi };

  my $filter_limit;
  $filter_limit->{subjects} = $ctx->{cla}->{limit_sub} if defined $ctx->{cla}->{limit_sub};
  $filter_limit->{hsps} = $ctx->{cla}->{limit_hsp} if defined $ctx->{cla}->{limit_hsp};

  # work through files in the list
 FILE_SCAN_LOOP:
  foreach my $file ( @{ $ctx->{cla}->{ files } } ) {

    $n_files++;

    # get an object to manage the file.
    my $bs = new GUS::Community::BulkSimilarity( new CBIL::Util::A {
      file    => GetFileClever( $file ),
	query   => \&GetQueryObject,
	  subject => \&GetSubjectTableAndSeqId,
	    types   => $ctx->{cla}->{ output },
	  } )
      ;

    #CBIL::Util::Disp::Display( $bs->{ parameters } );

    # parse into objects and submit to db
  SECTION_SCAN_LOOP:
    while ( my $o = $bs->getSectionObjects($filter_ns, $filter_su, $filter_sp, $filter_limit) ) {
      $n_queries++;
      #CBIL::Util::Disp::Display( $o );

      $o->submit();

      if ($n_queries % ($ctx->{cla}->{'log_frequency'} * 10) == 0) {
	print join( "\t", $queriesProcessed, "$n_queries entered", $o->getId(), scalar $o->getSimilarityFacts,`date`);
      } elsif ($n_queries % $ctx->{cla}->{'log_frequency'} == 0) {
	print join( "\t", $queriesProcessed, "$n_queries entered", $o->getId(), scalar $o->getSimilarityFacts)."\n";
      }

      $o->undefPointerCache();

      last FILE_SCAN_LOOP if $n_queries >= $ctx->{cla}->{ nqueries };

    }				# eo similarities in file
  }				# eo filenames

  my $result = "Processed $queriesProcessed and loaded similarities for $n_queries from $n_files files";
  print "\n$result\n";
  return $result;
}

# given a source_id we return the query object..
## NOTE: using primary key so just create object and return it!!
sub GetQueryObject{
  my $Line = shift;
  my $queryClassName = "GUS::Model::".$ctx->{cla}->{'query_table'};

  $queriesProcessed++;
  # extract the query id from the defline
  $Line =~ /^\>*(\S+)\s\((\d+)/;
  return undef if $2 == 0;	##there are no subjects for this one so don't bother retrieving from DB.
  my $id = $1;

  ##want to ignore things that already have done!!
  if ($ctx->{cla}->{'restart'}) {
    if (exists $ignore{$id}) {
      $countIgnored++;
      return undef;
    }
  }

  # get the query object 
  my $qObj = $queryClassName->new( { $query_table_pk => $id } );

  if ($qObj->retrieveFromDB()) { ##have object..
    $qObj->retrieveSimilarityFactsFromDB($ctx->{cla}->{subject_table}) if $ctx->{cla}->{update};
    return $qObj;
  }
	
  return undef;
}

##NOTE: we have the primary key already so just return expected....
sub GetSubjectTableAndSeqId {
  my $Id = shift;
  return undef unless $Id;
  return ( $subject_table_id, $Id );
}

# ----------------------------------------------------------------------

sub GetFileClever {
  my $F = shift;

  my $f;

  if ( $F =~ /\.gz$/ ) {
    $f = "gunzip -c $F|";
  } elsif ( $F =~ /\.Z$/ ) {
    $f = "zcat $F|";
  } elsif ( -f $F ) {
    $f = "<$F";
  } else {
    $f = GetFileClever( $F. '.gz' ) || GetFileClever( $F. '.gz' );
  }

  return $f;
}




1;

